{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"repo-guide","text":"<p>The <code>repo-guide</code> repository contains a tool that uses AI to generate guides for code repositories. It leverages large language models (LLMs) to analyze code and directory structures and produce documentation in Markdown format, suitable for use with tools like MkDocs.</p> <p>Dependencies:</p> <ul> <li><code>bleach</code> and <code>bleach-allowlist</code>: Used for sanitizing HTML content, preventing potential security vulnerabilities when processing code snippets.</li> <li><code>click</code>: Used for building command-line interfaces.</li> <li><code>gitpython</code>: Used for interacting with Git repositories, retrieving file contents, and respecting <code>.gitignore</code> rules.</li> <li><code>llm</code> and <code>llm-gemini</code>: Used to interface with LLMs, such as Gemini, for generating documentation from code. The <code>llm</code> library provides a general interface for interacting with LLMs, while <code>llm-gemini</code> provides specific support for Google's Gemini models.</li> <li><code>mkdocs</code> and <code>mkdocs-material</code>: Used for generating static HTML documentation from Markdown files.  <code>mkdocs-material</code> provides a specific theme to use with MkDocs.</li> <li><code>tqdm</code>: Used for displaying progress bars during documentation generation.</li> <li><code>tiktoken</code>: Used for counting tokens in text, which helps in managing LLM costs.</li> <li><code>magika</code>: Used to detect file types, helping to skip binary files. (Optional dependency)</li> <li><code>pytest</code>: Used for running tests. (Development dependency)</li> </ul> <p>These dependencies are managed by <code>pyproject.toml</code>, which specifies the project's metadata, dependencies, and build configuration. The file also defines optional dependencies for magika, development, and pre-commit hooks.</p> <p>Key Subdirectories:</p> <ul> <li><code>src</code>: Contains the source code for the <code>repo-guide</code> tool.<ul> <li><code>src/repo_guide</code>:  Holds the core logic, including the command-line interface (<code>cli.py</code>) and the <code>DocGenerator</code> class responsible for crawling directories, constructing prompts for the LLM, and generating documentation. The entry point is <code>src/repo_guide/__main__.py</code>, which calls the <code>cli</code> function defined in <code>src/repo_guide/cli.py</code>. The <code>cli.py</code> file defines the command-line interface using the <code>click</code> library.</li> </ul> </li> <li><code>tests</code>: Contains tests for validating the behavior of the <code>repo-guide</code> tool. The most interesting file in this directory is <code>tests/test_repo_guide.py</code>, which includes tests for prompt construction and end-to-end documentation generation.</li> <li><code>.github</code>:  Contains configuration files for GitHub Actions workflows.<ul> <li><code>.github/workflows</code>: Contains YAML files defining automated workflows for testing, publishing the package to PyPI, and deploying the generated documentation to GitHub Pages.  The key files include <code>publish_site.yml</code>, <code>test.yml</code>, and <code>publish.yml</code>.</li> </ul> </li> </ul> <p>Key Files:</p> <ul> <li><code>README.md</code>: Provides an overview of the <code>repo-guide</code> tool, including installation instructions, usage examples, and troubleshooting tips.</li> <li><code>pyproject.toml</code>: Specifies the project's metadata, dependencies, and build configuration. It uses the Hatch build system.  It also defines development dependencies like <code>pytest</code>.</li> <li><code>.python-version</code>: Specifies the Python version to use for the project (3.11).</li> <li><code>.gitignore</code>: Specifies intentionally untracked files that Git should ignore.</li> <li><code>.pre-commit-config.yaml</code>: Configures pre-commit hooks for code formatting and linting using Ruff.</li> <li><code>LICENSE</code>: Contains the Apache 2.0 license.</li> <li><code>.gitattributes</code>: Configures how Git handles line endings.</li> </ul> <p>How it works:</p> <p>The <code>repo-guide</code> tool takes a path to a Git repository (or a subdirectory within it) as input. It then uses the <code>DocGenerator</code> class to:</p> <ol> <li>Crawl the directory structure: It recursively traverses the input directory, identifying files and subdirectories.</li> <li>Filter files: It excludes files based on <code>.gitignore</code> rules, binary file detection (using <code>magika</code> if installed), and user-defined ignore patterns.</li> <li>Construct prompts: For each directory, it creates an XML prompt containing the directory's relative path, a list of its subdirectories with links to their generated README files, and the contents of the files within that directory. This prompt is carefully structured to provide the LLM with the necessary context to generate a meaningful description.</li> <li>Generate documentation: It sends the prompt to the LLM (e.g., Gemini) and receives a generated description in Markdown format.</li> <li>Write documentation: It writes the generated Markdown to a file named <code>README.md</code> within the corresponding directory in the output directory.</li> <li>Create MkDocs configuration: It generates a basic <code>mkdocs.yml</code> file to configure MkDocs for serving or building the generated documentation.</li> <li>Serve or deploy (optional): It can optionally start a local MkDocs server to preview the documentation or build and deploy the documentation to GitHub Pages.</li> </ol> <p>The GitHub Actions workflows automate the testing, publishing, and deployment processes, ensuring that the tool is continuously tested and that the generated documentation is kept up-to-date on GitHub Pages.</p>"},{"location":"_github/","title":".github","text":"<p>The <code>.github/workflows</code> directory contains GitHub Actions workflows that automate aspects of the project's development and deployment lifecycle. These workflows are defined using YAML files and are triggered by events such as pushes, pull requests, and releases.</p> <p>Here's a breakdown of the key files:</p> <ul> <li> <p>publish_site.yml: This workflow publishes the self-documentation generated by <code>repo-guide</code> to GitHub Pages. It's triggered when a new release is created or manually via <code>workflow_dispatch</code>. The workflow first runs tests on multiple Python versions. If the tests pass, it then builds and deploys the documentation using the <code>repo-guide</code> command with the <code>--gh-deploy</code> option. It also sets up caching to speed up subsequent builds. The <code>LLM_GEMINI_KEY</code> secret is used for features that integrate with the Gemini LLM.</p> </li> <li> <p>test.yml: This workflow runs tests on multiple Python versions whenever code is pushed or a pull request is made. It uses the <code>uv</code> package manager to install the project and its dependencies and then runs <code>pytest</code> to execute the tests.</p> </li> <li> <p>publish.yml: This workflow publishes the Python package to PyPI when a new release is created. It first runs tests on multiple Python versions. If the tests pass, it then builds the package using <code>uv build</code> and publishes it to PyPI using the <code>pypa/gh-action-pypi-publish</code> action. It configures an environment named \"release\" and requires write permissions for the id-token.</p> </li> </ul>"},{"location":"_github/workflows/","title":"workflows","text":"<p>The <code>.github/workflows</code> directory contains GitHub Actions workflows that automate various aspects of the project's development and deployment lifecycle.  These workflows are defined using YAML files and are triggered by events such as pushes, pull requests, and releases.</p> <p>Here's a breakdown of the key files:</p> <ul> <li> <p><code>publish_site.yml</code>: This workflow publishes the self-documentation generated by <code>repo-guide</code> to GitHub Pages. It's triggered when a new release is created or manually via <code>workflow_dispatch</code>. The workflow first runs tests on multiple Python versions. If the tests pass, it then builds and deploys the documentation using the <code>repo-guide</code> command with the <code>--gh-deploy</code> option. It also sets up caching to speed up subsequent builds. The <code>LLM_GEMINI_KEY</code> secret is used for features that integrate with the Gemini LLM.</p> </li> <li> <p><code>test.yml</code>: This workflow runs tests on multiple Python versions whenever code is pushed or a pull request is made. It uses the <code>uv</code> package manager to install the project and its dependencies and then runs <code>pytest</code> to execute the tests.</p> </li> <li> <p><code>publish.yml</code>: This workflow publishes the Python package to PyPI when a new release is created. It first runs tests on multiple Python versions. If the tests pass, it then builds the package using <code>uv build</code> and publishes it to PyPI using the <code>pypa/gh-action-pypi-publish</code> action.  It configures an environment named \"release\" and requires write permissions for the id-token.</p> </li> </ul>"},{"location":"src/","title":"src","text":"<p>The <code>repo-guide/src</code> directory serves as the root for the source code of the <code>repo-guide</code> tool.</p> <p>The key subdirectory within this directory is <code>repo_guide</code>, which contains the core application logic. This includes the command-line interface definition and the documentation generation processes.</p> <p>The entry point is <code>repo_guide/__main__.py</code>, which calls the <code>cli</code> function defined in <code>repo_guide/cli.py</code>.</p> <p><code>repo_guide/cli.py</code> defines the command-line interface using the <code>click</code> library. The <code>DocGenerator</code> class within this file manages the documentation generation process. This includes crawling the input directory, filtering files, constructing prompts for the LLM, generating documentation, writing the generated documentation to the output directory, and creating a basic <code>mkdocs.yml</code> configuration file. The <code>_build_prompt</code> method constructs an XML prompt containing directory structure and file contents to send to the LLM. The <code>cli</code> function orchestrates parsing command-line arguments, initializing the <code>DocGenerator</code>, generating the documentation, and optionally starting a local documentation server, and building/deploying the static site to GitHub Pages.</p>"},{"location":"src/repo_guide/","title":"repo_guide","text":"<p>The <code>repo_guide</code> directory contains the core logic for the <code>repo-guide</code> tool. It includes the command-line interface definition and the documentation generation process.</p> <p>The entry point for the application is the <code>__main__.py</code> file. It imports the <code>cli</code> function from the <code>cli.py</code> module and executes it when the script is run directly.</p> <p>The <code>cli.py</code> file defines the command-line interface using the <code>click</code> library. It defines options like <code>--model</code>, <code>--serve</code>, <code>--output-dir</code>, and <code>--ignore</code> to configure the documentation generation process.  It also contains the <code>DocGenerator</code> class, which handles the core logic of generating the documentation.</p> <p>The <code>DocGenerator</code> class is responsible for:</p> <ul> <li>Crawling the input directory.</li> <li>Filtering files based on ignore patterns and binary file detection.</li> <li>Constructing prompts for the LLM.</li> <li>Generating documentation using the LLM.</li> <li>Writing the generated documentation to the output directory.</li> <li>Creating a basic <code>mkdocs.yml</code> configuration file.</li> </ul> <p>The <code>_build_prompt</code> method is particularly important. It takes a directory and a list of files, and it constructs an XML prompt that is sent to the LLM. The prompt includes the relative path of the current directory, a list of subdirectories with links to their generated README files, and a list of files with their contents. The LLM uses this information to generate a description of the directory.</p> <p>The <code>cli</code> function in <code>cli.py</code> orchestrates the entire process. It parses the command-line arguments, initializes the <code>DocGenerator</code>, generates the documentation, and optionally starts a local documentation server using <code>mkdocs</code>. It also handles building and deploying the static site to GitHub Pages.</p>"},{"location":"tests/","title":"tests","text":"<p>The tests in the <code>repo-guide/tests</code> directory validate the behavior of the <code>repo-guide</code> tool. The most interesting file in this directory is <code>test_repo_guide.py</code>, which contains several tests for the core functionality, especially the prompt construction and end-to-end documentation generation.</p> <p>Here's a breakdown of some key tests:</p> <ul> <li> <p><code>test_version</code>: Verifies the CLI tool returns the correct version number.</p> </li> <li> <p><code>test_prompt_construction</code>: This test checks that the prompt sent to the LLM is constructed correctly for the root directory. It creates a temporary repository with a basic file structure, adds dummy generated readmes, and asserts that the prompt generated by <code>DocGenerator._build_prompt</code> matches the expected structure, including the correct paths, link URLs, and content for files and subdirectories.</p> </li> <li> <p><code>test_subdirectory_prompt_construction</code>: Similar to the previous test, but it focuses on generating prompts for a subdirectory (<code>src</code>). This ensures that relative paths within subdirectories are handled correctly.</p> </li> <li> <p><code>test_file_decoding_failures</code>: This test ensures that the tool gracefully handles files with encoding issues. It creates files with different encodings (UTF-8, Latin-1, and a broken UTF-16 file) and verifies that only readable files are included in the prompt, preventing errors during processing.</p> </li> <li> <p><code>test_repo_url</code>, <code>test_repo_url_with_subdirectory</code>, and <code>test_ssh_org_repo_url</code>: These tests validate the construction of the repository URL, which is used to create links to the original files in the repository. They test different scenarios, including cases where the tool is run from a subdirectory and cases where the repository URL is in SSH format.</p> </li> <li> <p><code>test_doc_generation_end_to_end</code> and <code>test_doc_generation_src_directory</code>: These are end-to-end tests that simulate the entire documentation generation process using the CLI. They create a temporary repository, run the <code>repo-guide</code> command, and verify that the generated documentation files are created in the correct locations with the expected content. <code>test_doc_generation_src_directory</code> tests the case where the documentation is generated for a subdirectory (<code>src</code>). They use a mock LLM model to avoid actually calling an external LLM service during testing.</p> </li> </ul>"}]}